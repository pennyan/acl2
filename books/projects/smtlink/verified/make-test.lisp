;; Copyright (C) 2022, University of British Columbia
;; Written by Mark Greenstreet (February 2nd 2022)
;;
;; License: A 3-clause BSD license.
;; See the LICENSE file distributed with ACL2

; Some xdoc documentation should go here.
; (make-test assertion :name test-name :prep prep-events :output output-spec)
;   assertion is a term that should evaluate to non-nil to indicate a successful test.
;   :name test-name,   test-name is printed with (cw ...) messages that
;                        indicate the success or failure of the test.
;                        Optional.
;   :prep prep-events, events that should be admitted locally (i.e. they are erased
;                        after the test) to facilitate running the test.  E.g. defun
;			 and defthm events.
;   :output output-spec,   Control the output.  By default, any prep-events, the
;     evaluation of the assertion, and the printing of the test result is done with
;     the output settings that were in effect when the make-test event-form is admitted.
;     The user can control the output by giving an output-spec.  The output-spec is
;     an alist mapping phases of the test to an output specification for with-output.
;     with-output.  The phases are:
;      :prep -- output generated while executing prep-events
;      :eval -- output generated whil evaluating assertion
;      :pass -- reporting a successful test
;      :fail -- reporting a failed test
;     Furthermore, there are a few "general" categories:
;      :outcome -- output of :pass or :fail.  Only used if :pass or :fail is omitted.
;      :all  -- used for any of :prep, :eval, :pass, or :fail that are not otherwise specified.
;      :all! -- like :all and includes the output from encapsulate, make-event, or progn forms
;                 generated by make-test.
;     The output spec for each of these can be an "ordinary" with-output spec, for example
;       (:prep . '(:off :all :on (error warning))
;     will only print errors and warnings generated by prep-events.
;
;     A few abbreviations are supported as well:
;      :on  -- enable all output and summary output.
;      :off -- disable all output and summary output.
;      :err -- only print errors and summary errors.
;      :warn -- only print errors and warnings.
;
;     A test-phase keyword can be included in the output-spec list without being
;     consed with an output spec.  This is equivalent to specifying :on :all.
;
;     Unless otherwise specified, initially a with-output form is executed with
;       :stack :push :off :all :summary-off :all
;     this disables all printing from internal forms generated by with-output,
;     and
;       :stack :pop
;     forms are executed for prep-events, and assertion evaluation.  This means
;     that they follow the same output enabling that was present when the make-test
;     was issued.  Test result reporting is done inside the with-output form for
;     assertion evaluation (e.g. :pass and :fail inherit the output specification
;     from :eval).  By default, :pass and :fail don't modify the output-spec -- if
;     :eval is the default, then :pass and :fail will default to printing with the
;     same output specification that was in effect when the make-test as issued.
;
;     An example
;       :output (:fail (:all :warn))
;     specifies to print a message if the test fails and to print any errors or
;     warnings that occur in prep-events or when evaluating the assertion.
;
; (make-test ...) is a macro that expands to an embedded event form.



(in-package "SMT")

(local (include-book "std/testing/must-fail" :dir :system))
(local (include-book "std/testing/must-succeed" :dir :system))
(include-book "std/util/bstar" :dir :system)
(set-state-ok t)

(local (defun spew (stuff)
  (prog2$
    (cw "spew: ~x0~%" stuff)
    stuff)))

(defun make-test-output-spec (x y default)
  (declare (xargs :ruler-extenders :all))
  (b* ((v (b* (((unless (consp x)) default)
	       ((cons xhd xtl) x)
	       (s (assoc-equal xhd y))
	       ((if s) (cdr s)))
	    (make-test-output-spec xtl y default))))
      (cond ((equal v :on) '(:on :all :summary-on :all))
            ((equal v :off) '(:off :all :summary-off :all))
            ((equal v :err) '(:off :all :on error :summary-off :all :summary-on acl2::errors))
	    ((equal v :warn) '(:off :all :on (error warning warning!)
			       :summary-off :all :summary-on (acl2::errors acl2::warnings)))
	    (t v))))
; Examples:
; (make-test-output-spec '(:cow)
; 		          '((:pass :on (comment error warning))
;			    (:outcome :on (error warning))
;			    (:all :on (peanut-butter))) 'oops)
;   -> (:on (comment error warning))
;
;  (make-test-output-spec '(:fail :outcome :all)
;		          '((:pass :on (comment error warning))
;			    (:outcome :on (error warning))
;			    (:all :on (peanut-butter))) 'oops)
; -> (:on (error warning))
;
; (make-test-output-spec '(:cow)
;  		          '((:pass :on (comment error warning))
;			    (:outcome :on (error warning))
;			    (:all :on (peanut-butter))) 'oops)
;   -> oops

; t if :stack and :pop appear as consecutive elements of output-spec
(defun make-test-stack-pop-p (output-spec)
  (and (consp output-spec)
       (consp (cdr output-spec))
       (or (and (equal (car output-spec) :stack)
		(equal (cadr output-spec) :pop))
	   (make-test-stack-pop-p (cdr output-spec)))))
; Examples
;   (make-test-stack-pop-p '(:stack :pop)) -> t
;   (make-test-stack-pop-p '(:stack :push)) -> nil
;   (make-test-stack-pop-p '(:off :all :on (comment error warning))) -> nil
;   (make-test-stack-pop-p '(42 big cows :stack :pop (goes the weasel)))

(defun make-test-test (assertion name output pop-flag)
  `(progn
     (with-output
       ,@(make-test-output-spec
	  (list (if assertion :pass :fail) :outcome :all :all!)
	  output
	  (if pop-flag nil '(:stack :pop)))
       (value-triple (cw "test ~s0ed: ~x1~%" ,(if assertion "pass" "fail") ,(kwote name))))
     (with-output ,@(make-test-output-spec '(all!) output :off)
		  (make-event ,(kwote `(value-triple ,assertion :check t))))))
; Examples:
;  (make-test-test t 'foo '((:fail . :on) (:outcome :stack :pop)) nil)
;  (make-test-test nil 'foo '((:fail . :on) (:outcome :stack :pop)) nil)

(defun make-test-fix-output (output)
  (b* (((unless (consp output)) nil)
       ((cons hd tl) output)
       (h (if (keywordp hd) (cons hd :on) hd)))
    (cons h (make-test-fix-output tl))))
; Example:
;   (make-test-fix-output '(:fail (:outcome :stack :pop)))
;   -> ((:FAIL . :ON) (:OUTCOME :STACK :POP))


(defun make-test-fn (assertion name prep output)
  (b* ((output (make-test-fix-output output))
       (prep-out (make-test-output-spec '(:prep :all :all!) output '(:stack :pop)))
       (prep-prog (if prep
		    `((local (with-output ,@prep-out (progn ,@prep))))
		    nil))
       (eval-out (make-test-output-spec '(:eval :all :all!) output '(:stack :pop)))
       (eval-pop (make-test-stack-pop-p eval-out)))
    `(with-output
       ,@(make-test-output-spec '(:top :all!) output '(:off :all :summary-off :all :stack :push))
      (progn
	(make-event ,(kwote `(encapsulate nil
          ,@prep-prog
	  (with-output ,@eval-out
	    (make-event (make-test-test ,assertion (quote ,name) (quote ,output) (quote ,eval-pop)))))))
	(value-triple :invisible)))))

; Examples:
;  (make-test-fn '(< 0 1) 'test-< nil '(:fail (:all . :warn)))
;  (make-test-fn '(< 1 0) 'test-< nil '(:fail (:all . :warn)))
;  (make-test-fn '(< (z) 1) 'test-< '((defun z () 0)) '(:fail (:all . :warn)))
;  (make-test-fn '(< (o) (z)) 'test-< '((defun z () 0) (defun o () 1)) '(:fail (:all . :warn)))

(defmacro make-test (assertion
		      &key
		      (name 'some-nameless-test)  ; the "name" for this test
		      (prep 'nil)   ; if you need to define stuff just for this test, do it here
		      (output 'nil)) ; what to print in the proof log
  (make-test-fn assertion name prep output))

(acl2::must-succeed (make-test (< 0 1)     :name test-< :output (:fail (:all . :warn))))
(acl2::must-fail    (make-test (< 1 0)     :name test-< :output (:fail (:all . :warn))))
(acl2::must-succeed (make-test (< (z) 1)   :name test-< :prep ((defun z () 0))                :output (:fail (:all . :warn))))
(acl2::must-fail    (make-test (< (o) (z)) :name test-< :prep ((defun z () 0) (defun o () 1)) :output (:fail (:all . :warn))))
(acl2::must-succeed (make-test (< (z) (o)) :name test-< :prep ((defun z () 0) (defun o () 1))))
(acl2::must-succeed (make-test (< (z) (o)) :name test-< :prep ((defun z () 0) (defun o () 1)) :output :all!))
(acl2::must-fail    (make-test (< (o) (z)) :name test-< :prep ((defun z () 0) (defun o () 1)) :output :all!))
