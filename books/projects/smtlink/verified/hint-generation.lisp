;; Copyright (C) 2015, University of British Columbia
;; Written by Yan Peng (Oct 26th 2021)
;;
;; License: A 3-clause BSD license.
;; See the LICENSE file distributed with ACL2
;;

(in-package "SMT")
(include-book "std/util/bstar" :dir :system)
(include-book "xdoc/top" :dir :system)
(include-book "std/util/define" :dir :system)
(include-book "centaur/fty/top" :dir :system)
(include-book "ordinals/lexicographic-ordering-without-arithmetic" :dir :system)

(include-book "hint-options")
(include-book "typed-term-fns")
(include-book "judgement-fns")
(include-book "lambda-substitution")

(set-state-ok t)

(local (in-theory (disable (:executable-counterpart typed-term)
                           pseudo-termp pseudo-term-listp)))

(define get-type-helper ((term pseudo-termp)
                         (judge pseudo-termp)
                         (supertype type-to-types-alist-p))
  :returns (type symbolp)
  (b* ((term (pseudo-term-fix term))
       (judge (pseudo-term-fix judge))
       (supertype (type-to-types-alist-fix supertype))
       (type-pred-list (look-up-type-predicate term judge supertype))
       ((unless (equal (len type-pred-list) 1))
        (er hard? 'hint-generation=>get-type-helper
            "Found multiple type predicates: ~q0" type-pred-list)))
    (caar type-pred-list)))

(define get-type ((tterm typed-term-p)
                  (supertype type-to-types-alist-p))
  :guard (good-typed-term-p tterm)
  :returns (type symbolp)
  (b* ((tterm (typed-term-fix tterm))
       ((unless (good-typed-term-p tterm)) nil)
       (supertype (type-to-types-alist-fix supertype))
       ((typed-term tt) tterm)
       ((typed-term ttt)
        (if (or (equal (typed-term->kind tt) 'ifp)
                (equal (typed-term->kind tt) 'fncallp))
            (typed-term->top tt) tt)))
    (get-type-helper tt.term ttt.judgements supertype)))

(define get-type-list ((tterm-lst typed-term-list-p)
                       (supertype type-to-types-alist-p))
  :guard (good-typed-term-list-p tterm-lst)
  :returns (types symbol-listp)
  :measure (len tterm-lst)
  (b* ((tterm-lst (typed-term-list-fix tterm-lst))
       ((unless (good-typed-term-list-p tterm-lst)) nil)
       (supertype (type-to-types-alist-fix supertype))
       ((unless (consp tterm-lst)) nil)
       ((cons tterm-hd tterm-tl) tterm-lst))
    (cons (get-type tterm-hd supertype)
          (get-type-list tterm-tl supertype))))

(define set-function-return-type ((function smt-function-p)
                                  (supertype type-to-types-alist-p)
                                  (trans-type symbolp)
                                  (fn-acc symbol-trans-hint-alist-p)
                                  state)
  :returns (mv (new-fn smt-function-p)
               (new-acc symbol-trans-hint-alist-p))
  (b* ((function (smt-function-fix function))
       (trans-type (symbol-fix trans-type))
       (fn-acc (symbol-trans-hint-alist-fix fn-acc))
       ((smt-function f) function)
       ((unless (>= (len f.returns) 1))
        (prog2$ (er hard? 'hint-generation=>set-function-return-type
                    "Missing return type for function ~q0" f.name)
                (mv f fn-acc)))
       (return-name (car f.returns))
       (return-thm
        (acl2::meta-extract-formula-w return-name (w state)))
       ((unless (and return-thm (pseudo-termp return-thm)))
        (prog2$
         (er hard? 'hint-generation=>set-function-return-type
             "Formula returned by meta-extract ~p0 is not a pseudo-termp: ~p1~%"
             return-name return-thm)
         (mv f fn-acc)))
       (return-thm-expanded (expand-lambda return-thm))
       ((mv okp type)
        (case-match return-thm-expanded
          (('implies & (type &)) (mv t type))
          ((type &) (mv t type))
          (& (mv nil nil))))
       ((unless (and okp (symbolp type) (assoc-equal type supertype)))
        (prog2$ (er hard? 'hint-generation=>set-function-return-type
                    "Malformed returns theorem: ~q0" return-thm-expanded)
                (mv f fn-acc)))
       (trans-hint (make-trans-hint
                    :type-translation trans-type
                    :function-translation f.translation)))
    (mv (change-smt-function function :return-type type)
        (acons f.name trans-hint fn-acc))))

(define set-function-return-type-list ((functions smt-function-list-p)
                                       (supertype type-to-types-alist-p)
                                       (trans-type symbolp)
                                       (fn-acc symbol-trans-hint-alist-p)
                                       state)
  :returns (mv (new-des-lst smt-function-list-p)
               (new-acc symbol-trans-hint-alist-p))
  :measure (len functions)
  (b* ((functions (smt-function-list-fix functions))
       (supertype (type-to-types-alist-fix supertype))
       (trans-type (symbol-fix trans-type))
       (fn-acc (symbol-trans-hint-alist-fix fn-acc))
       ((unless (consp functions)) (mv nil fn-acc))
       ((cons fn-hd fn-tl) functions)
       ((mv new-fn-hd acc-1)
        (set-function-return-type
         fn-hd supertype trans-type fn-acc state))
       ((mv new-fn-tl acc-2)
        (set-function-return-type-list
         fn-tl supertype trans-type acc-1 state)))
    (mv (cons new-fn-hd new-fn-tl) acc-2)))

(define set-sum ((sum smt-sum-p)
                 (supertype type-to-types-alist-p)
                 (trans-type symbolp)
                 (fn-acc symbol-trans-hint-alist-p)
                 state)
  :returns (mv (new-sum smt-sum-p)
               (new-acc symbol-trans-hint-alist-p))
  (b* ((sum (smt-sum-fix sum))
       (supertype (type-to-types-alist-fix supertype))
       (trans-type (symbol-fix trans-type))
       (fn-acc (symbol-trans-hint-alist-fix fn-acc))
       ((smt-sum s) sum)
       ((mv func-cons acc-1)
        (set-function-return-type
         s.constructor supertype trans-type fn-acc state))
       ((mv func-des acc-2)
        (set-function-return-type-list
         s.destructors supertype trans-type acc-1 state)))
    (mv (change-smt-sum sum
                        :constructor func-cons
                        :destructors func-des)
        acc-2)))

(define set-sum-list ((sum-lst smt-sum-list-p)
                      (supertype type-to-types-alist-p)
                      (trans-type symbolp)
                      (fn-acc symbol-trans-hint-alist-p)
                      state)
  :returns (mv (new-sums smt-sum-list-p)
               (new-acc symbol-trans-hint-alist-p))
  :measure (len sum-lst)
  (b* ((sum-lst (smt-sum-list-fix sum-lst))
       (supertype (type-to-types-alist-fix supertype))
       (trans-type (symbol-fix trans-type))
       (fn-acc (symbol-trans-hint-alist-fix fn-acc))
       ((unless (consp sum-lst)) (mv nil fn-acc))
       ((cons sum-hd sum-tl) sum-lst)
       ((mv new-sum-hd acc-hd)
        (set-sum sum-hd supertype trans-type fn-acc state))
       ((mv new-sum-tl acc-tl)
        (set-sum-list sum-tl supertype trans-type acc-hd state)))
    (mv (cons new-sum-hd new-sum-tl) acc-tl)))

(define set-types ((type smt-type-p)
                   (supertype type-to-types-alist-p)
                   (fn-acc symbol-trans-hint-alist-p)
                   state)
  :returns (mv (new-type smt-type-p)
               (new-acc symbol-trans-hint-alist-p))
  (b* ((type (smt-type-fix type))
       (supertype (type-to-types-alist-fix supertype))
       (fn-acc (symbol-trans-hint-alist-fix fn-acc))
       ((smt-type tp) type)
       (trans-type (smt-function->translation tp.recognizer))
       ((mv new-sums new-acc)
        (set-sum-list tp.sums supertype trans-type fn-acc state))
       ((unless tp.kind)
        (mv (change-smt-type type :sums new-sums) new-acc))
       ((smt-function k) tp.kind)
       (trans-kind (make-trans-hint :type-translation nil
                                    :function-translation k.translation)))
    (mv (change-smt-type type :sums new-sums)
        (acons k.name trans-kind new-acc))))

(define update-user-types ((fn symbolp)
                           (types symbol-smt-type-alist-p)
                           (supertype type-to-types-alist-p)
                           (acc trusted-hint-p)
                           state)
  :returns (new-acc trusted-hint-p)
  (b* ((fn (symbol-fix fn))
       (types (symbol-smt-type-alist-fix types))
       (supertype (type-to-types-alist-fix supertype))
       (acc (trusted-hint-fix acc))
       ((trusted-hint th) acc)
       (exists? (assoc-equal fn types))
       ((unless exists?) acc)
       ((if (assoc-equal fn th.user-types)) acc)
       ((mv new-tp new-user-type-fns)
        (set-types (cdr exists?) supertype th.user-type-fns state)))
    (change-trusted-hint acc
                         :user-types (acons fn new-tp th.user-types)
                         :user-type-fns new-user-type-fns)))

(defines hint-generation
  :well-founded-relation l<
  :flag-local nil
  :verify-guards nil

  (define fncall-hint-generation ((tterm typed-term-p)
                                  (hint-options hint-options-p)
                                  (acc trusted-hint-p)
                                  state)
    :guard (and (good-typed-term-p tterm)
                (equal (typed-term->kind tterm) 'fncallp))
    :returns (trusted-hint trusted-hint-p)
    :measure (list (acl2-count (typed-term->term tterm)) 0)
    (b* (((unless (mbt (and (typed-term-p tterm)
                            (hint-options-p hint-options)
                            (equal (typed-term->kind tterm) 'fncallp)
                            (good-typed-term-p tterm)
                            (trusted-hint-p acc))))
          (make-trusted-hint))
         ((hint-options ho) hint-options)
         ((trusted-hint th) acc)
         ((typed-term tt) tterm)
         ((cons fn &) tt.term)
         (tta (typed-term-fncall->actuals tt))
         ((if (member-equal fn (SMT-basics)))
          (hint-generation-list tta ho acc state))
         ((if (assoc-equal fn ho.supertype))
          (hint-generation-list
           tta ho
           (update-user-types fn ho.type ho.supertype acc state)
           state))
         (exists? (assoc-equal fn ho.function))
         ((unless exists?) acc)
         ((if (assoc-equal fn th.uninterpreted)) acc)
         (func (cdr exists?))
         (return-type (get-type tterm ho.supertype))
         (formal-types (get-type-list tta ho.supertype))
         (uninterpreted (change-smt-function func
                                             :formal-types formal-types
                                             :return-type return-type)))
      (hint-generation-list
       tta ho
       (change-trusted-hint acc
                            :uninterpreted
                            (acons fn uninterpreted th.uninterpreted))
       state)))

  (define if-hint-generation ((tterm typed-term-p)
                              (hint-options hint-options-p)
                              (acc trusted-hint-p)
                              state)
    :guard (and (good-typed-term-p tterm)
                (equal (typed-term->kind tterm) 'ifp))
    :returns (trusted-hint trusted-hint-p)
    :measure (list (acl2-count (typed-term->term tterm)) 0)
    (b* (((unless (mbt (and (typed-term-p tterm)
                            (hint-options-p hint-options)
                            (equal (typed-term->kind tterm) 'ifp)
                            (good-typed-term-p tterm)
                            (trusted-hint-p acc))))
          (make-trusted-hint))
         ((hint-options ho) hint-options)
         ((typed-term tt) tterm)
         (ttc (typed-term-if->cond tt))
         (ttn (typed-term-if->then tt))
         (tte (typed-term-if->else tt))
         (acc-cond (hint-generation ttc ho acc state))
         (acc-then (hint-generation ttn ho acc-cond state)))
      (hint-generation tte ho acc-then state)))

  (define hint-generation ((tterm typed-term-p)
                           (hint-options hint-options-p)
                           (acc trusted-hint-p)
                           state)
    :guard (good-typed-term-p tterm)
    :returns (trusted-hint trusted-hint-p)
    :measure (list (acl2-count (typed-term->term tterm)) 1)
    (b* (((unless (mbt (and (typed-term-p tterm)
                            (good-typed-term-p tterm)
                            (hint-options-p hint-options)
                            (trusted-hint-p acc))))
          (make-trusted-hint))
         ((if (equal (typed-term->kind tterm) 'variablep)) acc)
         ((if (equal (typed-term->kind tterm) 'quotep)) acc)
         ((if (equal (typed-term->kind tterm) 'ifp))
          (if-hint-generation tterm hint-options acc state))
         ((if (equal (typed-term->kind tterm) 'fncallp))
          (fncall-hint-generation tterm hint-options acc state)))
      (prog2$ (er hard? 'hint-generation=>hint-generation
                  "Found lambda term in goal.~%")
              acc)))

  (define hint-generation-list ((tterm-lst typed-term-list-p)
                                (hint-options hint-options-p)
                                (acc trusted-hint-p)
                                state)
    :guard (good-typed-term-list-p tterm-lst)
    :returns (trusted-hint trusted-hint-p)
    :measure (list (acl2-count (typed-term-list->term-lst tterm-lst)) 1)
    (b* (((unless (mbt (and (typed-term-list-p tterm-lst)
                            (good-typed-term-list-p tterm-lst)
                            (hint-options-p hint-options)
                            (trusted-hint-p acc))))
          (make-trusted-hint))
         ((unless (consp tterm-lst)) acc)
         ((cons tterm-hd tterm-tl) tterm-lst)
         (acc-car (hint-generation tterm-hd hint-options acc state)))
      (hint-generation-list tterm-tl hint-options acc-car state)))
  )

(verify-guards hint-generation)

(define hint-generation-cp ((cl pseudo-term-listp)
                            (hints t)
                            state)
  (b* ((cl (pseudo-term-list-fix cl))
       ((unless (smtlink-hint-p hints)) (value (list cl)))
       (goal (disjoin cl))
       ((mv okp tterm)
        (case-match goal
          (('implies judges term)
           (mv t (make-typed-term :term term
                                  :path-cond ''t
                                  :judgements judges)))
          (& (mv nil (make-typed-term)))))
       ((unless okp)
        (prog2$ (er hard? 'hint-generation=>hint-generation-cp
                    "The input term is of wrong shape.~%")
                (value (list cl))))
       ((unless (good-typed-term-p tterm))
        (prog2$ (er hard? 'hint-generation=>hint-generation-cp
                    "Not a good-typed-term-p: ~q0" tterm)
                (value (list cl))))
       (next-cp (cdr (assoc-equal 'hint-generation *SMT-architecture*)))
       ((if (null next-cp)) (value (list cl)))
       (options (construct-hint-options hints))
       (trusted-hint (hint-generation tterm options (make-trusted-hint) state))
       (new-hint (change-smtlink-hint hints :trusted-hint trusted-hint))
       (the-hint `(:clause-processor (,next-cp clause ',new-hint))))
    (value (list `((hint-please ',the-hint) ,goal)))))

(defthm correctness-of-hint-generation-cp
  (implies (and (pseudo-term-listp cl)
                (alistp a)
                (ev-smtcp
                 (conjoin-clauses
                  (acl2::clauses-result
                   (hint-generation-cp cl hint state)))
                 a))
           (ev-smtcp (disjoin cl) a))
  :hints (("Goal"
           :in-theory (enable hint-generation-cp hint-generation)))
  :rule-classes :clause-processor)
