;; Copyright (C) 2015, University of British Columbia
;; Written by Yan Peng (Oct 26th 2021)
;;
;; License: A 3-clause BSD license.
;; See the LICENSE file distributed with ACL2
;;

(in-package "SMT")
(include-book "std/util/bstar" :dir :system)
(include-book "xdoc/top" :dir :system)
(include-book "std/util/define" :dir :system)
(include-book "centaur/fty/top" :dir :system)
(include-book "ordinals/lexicographic-ordering-without-arithmetic" :dir :system)

(include-book "hint-options")
(include-book "typed-term-fns")
(include-book "judgement-fns")

(local (in-theory (disable (:executable-counterpart typed-term)
                           pseudo-termp pseudo-term-listp)))

(set-bogus-mutual-recursion-ok t)

(define get-type-helper ((term pseudo-termp)
                         (judge pseudo-termp)
                         (supertype type-to-types-alist-p))
  :returns (type symbolp)
  (b* ((term (pseudo-term-fix term))
       (judge (pseudo-term-fix judge))
       (supertype (type-to-types-alist-fix supertype))
       (type-pred-list (look-up-type-predicate term judge supertype))
       ((unless (equal (len type-pred-list) 1))
        (er hard? 'hint-generation=>get-type-helper
            "Found multiple type predicates: ~q0" type-pred-list)))
    (caar type-pred-list)))

(define get-type ((tterm typed-term-p)
                  (supertype type-to-types-alist-p))
  :guard (good-typed-term-p tterm)
  :returns (type symbolp)
  (b* ((tterm (typed-term-fix tterm))
       ((unless (good-typed-term-p tterm)) nil)
       (supertype (type-to-types-alist-fix supertype))
       ((typed-term tt) tterm)
       ((typed-term ttt)
        (if (or (equal (typed-term->kind tt) 'ifp)
                (equal (typed-term->kind tt) 'fncallp))
            (typed-term->top tt) tt)))
    (get-type-helper tt.term ttt.judgements supertype)))

(define get-type-list ((tterm-lst typed-term-list-p)
                       (supertype type-to-types-alist-p))
  :guard (good-typed-term-list-p tterm-lst)
  :returns (types symbol-listp)
  :measure (len tterm-lst)
  (b* ((tterm-lst (typed-term-list-fix tterm-lst))
       ((unless (good-typed-term-list-p tterm-lst)) nil)
       (supertype (type-to-types-alist-fix supertype))
       ((unless (consp tterm-lst)) nil)
       ((cons tterm-hd tterm-tl) tterm-lst))
    (cons (get-type tterm-hd supertype)
          (get-type-list tterm-tl supertype))))

(defines hint-generation
  :well-founded-relation l<
  :flag-local nil
  :verify-guards nil

  (define fncall-hint-generation ((tterm typed-term-p)
                                  (hint-options hint-options-p)
                                  (acc symbol-uninterpreted-alist-p))
    :guard (and (good-typed-term-p tterm)
                (equal (typed-term->kind tterm) 'fncallp))
    :returns (uninterpreted symbol-uninterpreted-alist-p)
    :measure (list (acl2-count (typed-term->term tterm)) 0)
    (b* (((unless (mbt (and (typed-term-p tterm)
                            (hint-options-p hint-options)
                            (equal (typed-term->kind tterm) 'fncallp)
                            (good-typed-term-p tterm)
                            (symbol-uninterpreted-alist-p acc))))
          nil)
         ((hint-options ho) hint-options)
         ((typed-term tt) tterm)
         ((cons fn &) tt.term)
         (tta (typed-term-fncall->actuals tt))
         ((if (member-equal fn (SMT-basics)))
          (hint-generation-list tta ho acc))
         (return-type (get-type tterm ho.supertype))
         (formal-types (get-type-list tta ho.supertype))
         (uninterpreted (make-uninterpreted :formal-types formal-types
                                            :return-type return-type)))
      (hint-generation-list tta ho (acons fn uninterpreted acc))))

  (define if-hint-generation ((tterm typed-term-p)
                              (hint-options hint-options-p)
                              (acc symbol-uninterpreted-alist-p))
    :guard (and (good-typed-term-p tterm)
                (equal (typed-term->kind tterm) 'ifp))
    :returns (uninterpreted symbol-uninterpreted-alist-p)
    :measure (list (acl2-count (typed-term->term tterm)) 0)
    (b* (((unless (mbt (and (typed-term-p tterm)
                            (hint-options-p hint-options)
                            (equal (typed-term->kind tterm) 'ifp)
                            (good-typed-term-p tterm)
                            (symbol-uninterpreted-alist-p acc))))
          nil)
         ((hint-options ho) hint-options)
         ((typed-term tt) tterm)
         (ttc (typed-term-if->cond tt))
         (ttn (typed-term-if->then tt))
         (tte (typed-term-if->else tt))
         (acc-cond (hint-generation ttc ho acc))
         (acc-then (hint-generation ttn ho acc-cond)))
      (hint-generation tte ho acc-then)))

  (define hint-generation ((tterm typed-term-p)
                           (hint-options hint-options-p)
                           (acc symbol-uninterpreted-alist-p))
    :guard (good-typed-term-p tterm)
    :returns (uninterpreted symbol-uninterpreted-alist-p)
    :measure (list (acl2-count (typed-term->term tterm)) 1)
    (b* (((unless (mbt (and (typed-term-p tterm)
                            (good-typed-term-p tterm)
                            (hint-options-p hint-options)
                            (symbol-uninterpreted-alist-p acc))))
          nil)
         ((if (equal (typed-term->kind tterm) 'variablep)) acc)
         ((if (equal (typed-term->kind tterm) 'quotep)) acc)
         ((if (equal (typed-term->kind tterm) 'ifp))
          (if-hint-generation tterm hint-options acc))
         ((if (equal (typed-term->kind tterm) 'fncallp))
          (fncall-hint-generation tterm hint-options acc)))
      (prog2$ (er hard? 'hint-generation=>hint-generation
                  "Found lambda term in goal.~%")
              acc)))

  (define hint-generation-list ((tterm-lst typed-term-list-p)
                                (hint-options hint-options-p)
                                (acc symbol-uninterpreted-alist-p))
    :guard (good-typed-term-list-p tterm-lst)
    :returns (uninterpreted symbol-uninterpreted-alist-p)
    :measure (list (acl2-count (typed-term-list->term-lst tterm-lst)) 1)
    (b* (((unless (mbt (and (typed-term-list-p tterm-lst)
                            (good-typed-term-list-p tterm-lst)
                            (hint-options-p hint-options)
                            (symbol-uninterpreted-alist-p acc))))
          nil)
         ((unless (consp tterm-lst)) acc)
         ((cons tterm-hd tterm-tl) tterm-lst)
         (acc-car (hint-generation tterm-hd hint-options acc)))
      (hint-generation-list tterm-tl hint-options acc-car)))
  )

(verify-guards hint-generation)

(define hint-generation-cp ((cl pseudo-term-listp)
                            (hints t))
  :returns (new-cl pseudo-term-list-listp
                   :hints (("Goal" :in-theory (enable pseudo-termp))))
  (b* ((cl (pseudo-term-list-fix cl))
       ((unless (smtlink-hint-p hints)) (list cl))
       (goal (disjoin cl))
       ((mv okp tterm)
        (case-match goal
          (('implies judges term)
           (mv t (make-typed-term :term term
                                  :path-cond ''t
                                  :judgements judges)))
          (& (mv nil (make-typed-term)))))
       ((unless okp)
        (prog2$ (er hard? 'hint-generation=>hint-generation-cp
                    "The input term is of wrong shape.~%")
                (list cl)))
       ((unless (good-typed-term-p tterm))
        (prog2$ (er hard? 'hint-generation=>hint-generation-cp
                    "Not a good-typed-term-p: ~q0" tterm)
                (list cl)))
       (next-cp (cdr (assoc-equal 'hint-generation *SMT-architecture*)))
       ((if (null next-cp)) (list cl))
       (options (construct-hint-options hints))
       (uninterpreted (hint-generation tterm options nil))
       (new-hint (change-smtlink-hint hints :uninterpreted uninterpreted))
       (the-hint `(:clause-processor (,next-cp clause ',new-hint))))
    (list `((hint-please ',the-hint) ,goal))))

(defthm correctness-of-hint-generation-cp
  (implies (and (pseudo-term-listp cl)
                (alistp a)
                (ev-smtcp
                 (conjoin-clauses
                  (hint-generation-cp cl hint))
                 a))
           (ev-smtcp (disjoin cl) a))
  :hints (("Goal"
           :in-theory (enable hint-generation-cp hint-generation)))
  :rule-classes :clause-processor)
