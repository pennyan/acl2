;; Copyright (C) 2015, University of British Columbia
;; Written (originally) by Yan Peng (11th October, 2021)
;;
;; License: A 3-clause BSD license.
;; See the LICENSE file distributed with ACL2

(in-package "SMT")
(include-book "centaur/fty/top" :dir :system)
(include-book "xdoc/top" :dir :system)
(include-book "std/util/define" :dir :system)
(include-book "std/strings/top" :dir :system)

(include-book "../../verified/hint-interface")
(include-book "../../verified/basics")
(include-book "../property/datatype-property")
(include-book "translate-variable")
(include-book "translate-type")
(include-book "translate-quote")

(local (in-theory (enable paragraph-p word-p string-or-symbol-p)))

(define create-destructor ((destructor smt-function-p)
                           (types symbol-smt-datatype-alist-p))
  :returns (translated paragraph-p)
  (b* ((destructor (smt-function-fix destructor))
       ((smt-function f) destructor)
       ((trans-hint th) f.translation-hint)
       (exists? (assoc-equal th.return-type types))
       ((unless exists?)
        (er hard? 'translate-user-type=>create-destructor
            "Unrecognized type ~p0, consider adding it to the hint.~%"
            th.return-type)))
    `("('" ,(translate-variable th.translation) "', "
      ,(translate-type (cdr exists?)) ")")))

(define create-destructors ((destructors smt-function-list-p)
                            (types symbol-smt-datatype-alist-p))
  :returns (translated paragraph-p)
  :measure (len destructors)
  (b* ((destructors (smt-function-list-fix destructors))
       ((unless (consp destructors)) nil)
       ((cons des-hd des-tl) destructors))
    `(", " ,(create-destructor des-hd types)
      ,@(create-destructors des-tl types))))

(define create-sum ((type smt-datatype-p)
                    (sum smt-sum-p)
                    (types symbol-smt-datatype-alist-p))
  :returns (translated paragraph-p)
  (b* ((type (smt-datatype-fix type))
       ((smt-sum s) (smt-sum-fix sum))
       (name (translate-type type))
       (trans-name (trans-hint->translation
                    (smt-function->translation-hint s.constructor)))
       (constructor (translate-variable trans-name))
       (translated-destructors (create-destructors s.destructors types)))
    `(,name ".declare( '" ,constructor
            "'" ,translated-destructors " )" #\Newline)))

(define create-sum-list ((type smt-datatype-p)
                         (sum-lst smt-sum-list-p)
                         (types symbol-smt-datatype-alist-p))
  :returns (translated paragraph-p)
  :measure (len sum-lst)
  (b* ((type (smt-datatype-fix type))
       (sum-lst (smt-sum-list-fix sum-lst))
       ((unless (consp sum-lst)) nil)
       ((cons sum-hd sum-tl) sum-lst))
    (cons (create-sum type sum-hd types)
          (create-sum-list type sum-tl types))))

(define create-sum-declare ((type smt-datatype-p)
                            (types symbol-smt-datatype-alist-p))
  :guard (equal (smt-datatype-kind type) :sumtype)
  :returns (translated paragraph-p)
  (b* ((type (smt-datatype-fix type))
       ((unless (mbt (equal (smt-datatype-kind type) :sumtype))) nil))
    (create-sum-list type (smt-datatype-sumtype->sums type) types)))

(define translate-kind-sum ((recognizer smt-function-p)
                            (destructors smt-function-list-p))
  :returns (translation paragraph-p)
  :measure (len destructors)
  (b* ((recognizer (smt-function-fix recognizer))
       (destructors (smt-function-list-fix destructors))
       ((smt-function r) recognizer)
       ((trans-hint rth) r.translation-hint)
       ((unless (consp destructors)) nil)
       ((cons des-hd des-tl) destructors)
       ((smt-function d) des-hd)
       ((trans-hint dth) d.translation-hint))
    (cons `(,(translate-variable rth.translation) "."
            ,(translate-variable dth.translation) "(x), ")
          (translate-kind-sum recognizer des-tl))))

(define translate-kind-body ((rec smt-function-p)
                             (sum-lst smt-sum-list-p)
                             (symbol-map symbol-string-alistp))
  :returns (translation paragraph-p)
  :measure (len sum-lst)
  (b* ((rec (smt-function-fix rec))
       (sum-lst (smt-sum-list-fix sum-lst))
       (symbol-map (symbol-string-alist-fix symbol-map))
       ((unless (consp sum-lst)) `("Symbol_z3.z3Sym.kindNotFound"))
       ((cons sum-hd sum-tl) sum-lst)
       ((smt-sum s) sum-hd)
       ((smt-function c) s.constructor)
       ((trans-hint cth) c.translation-hint)
       ((smt-function r) rec)
       ((trans-hint rth) r.translation-hint)
       (tag-trans (cdr (assoc-equal s.tag symbol-map)))
       ((unless tag-trans)
        (er hard? 'translate-user-type=>translate-kind-body
            "Tag doesn't exist in symbol map: ~p0 ~p1~%" s.tag symbol-map))
       (trans-tl (translate-kind-body rec sum-tl symbol-map)))
    `("If(x == " ,(translate-variable rth.translation) "."
      ,(translate-variable cth.translation)
      "(" ,(translate-kind-sum r s.destructors) "), "
      ,tag-trans ", "
      ,trans-tl ")" )))

(define translate-kind ((kind smt-function-p)
                        (rec smt-function-p)
                        (sum-lst smt-sum-list-p)
                        (symbol-map symbol-string-alistp))
  :returns (translation paragraph-p)
  (b* ((kind (smt-function-fix kind))
       (rec (smt-function-fix rec))
       (sum-lst (smt-sum-list-fix sum-lst))
       (symbol-map (symbol-string-alist-fix symbol-map))
       ((smt-function k) kind)
       ((trans-hint kth) k.translation-hint)
       (first-line `("def " ,(translate-variable kth.translation)
                     "(x): return "))
       (kind-body (translate-kind-body rec sum-lst symbol-map)))
    `(,first-line ,kind-body #\Newline)))

(define create-sumtype ((type smt-datatype-p)
                        (symbol-map symbol-string-alistp)
                        (acc pseudo-term-list-listp)
                        (types symbol-smt-datatype-alist-p))
  :guard (equal (smt-datatype-kind type) :sumtype)
  :returns (mv (translated paragraph-p)
               (properties pseudo-term-list-listp)
               (kind paragraph-p))
  (b* ((type (smt-datatype-fix type))
       (symbol-map (symbol-string-alist-fix symbol-map))
       (acc (pseudo-term-list-list-fix acc))
       ((unless (equal (smt-datatype-kind type) :sumtype))
        (mv nil nil nil))
       (tp.recognizer (smt-datatype->recognizer type))
       (tp.kind (smt-datatype-sumtype->kind type))
       (tp.sums (smt-datatype-sumtype->sums type))
       (name (translate-type type))
       (datatype `(,name " = Datatype( '" ,name "' )" #\Newline))
       (declares (create-sum-declare type types))
       (new-acc (datatype-property type acc))
       ((unless tp.kind) (mv `(,datatype ,declares) new-acc nil))
       (curr-kind (translate-kind tp.kind tp.recognizer tp.sums symbol-map)))
    (mv `(,datatype ,declares) new-acc curr-kind)))

(local (in-theory (enable paragraph-p word-p)))

(define create-type-names ((types symbol-smt-datatype-alist-p))
  :returns (created-names paragraph-p)
  :measure (len (symbol-smt-datatype-alist-fix types))
  (b* ((types (symbol-smt-datatype-alist-fix types))
       ((unless (consp types)) nil)
       ((cons t-hd t-tl) types)
       ((cons & tp) t-hd)
       (tp.recognizer (smt-datatype->recognizer tp))
       (trans-sym (trans-hint->translation
                   (smt-function->translation-hint
                    tp.recognizer)))
       (translated-name (translate-variable trans-sym))
       (names-tl (create-type-names t-tl)))
    (cons `(,translated-name ", ") names-tl)))

(define create-sumtype-list ((sumtypes symbol-smt-datatype-alist-p)
                             (symbol-map symbol-string-alistp)
                             (types symbol-smt-datatype-alist-p)
                             (acc pseudo-term-list-listp)
                             (kind paragraph-p))
  :returns (mv (translated paragraph-p)
               (properties pseudo-term-list-listp)
               (new-kind paragraph-p))
  :measure (len (symbol-smt-datatype-alist-fix sumtypes))
  (b* ((sumtypes (symbol-smt-datatype-alist-fix sumtypes))
       (symbol-map (symbol-string-alist-fix symbol-map))
       (acc (pseudo-term-list-list-fix acc))
       (kind (paragraph-fix kind))
       ((unless (consp sumtypes)) (mv nil acc kind))
       ((cons t-hd t-tl) sumtypes)
       ((cons & tp) t-hd)
       ((unless (equal (smt-datatype-kind tp) :sumtype)) (mv nil acc kind))
       ((mv trans acc-1 kind-hd) (create-sumtype tp symbol-map acc types))
       (kind-1 (cons kind-hd kind))
       ((mv trans-tl acc-2 kind-2)
        (create-sumtype-list t-tl symbol-map types acc-1 kind-1)))
    (mv (cons trans trans-tl) acc-2 kind-2)))

(define create-sumtype-list-top ((sumtypes symbol-smt-datatype-alist-p)
                                 (symbol-map symbol-string-alistp)
                                 (types symbol-smt-datatype-alist-p))
  :returns (mv (translated paragraph-p)
               (properties pseudo-term-list-listp))
  (b* ((sumtypes (symbol-smt-datatype-alist-fix sumtypes))
       (symbol-map (symbol-string-alist-fix symbol-map))
       ((if (null sumtypes)) (mv nil nil))
       (names (create-type-names sumtypes))
       (created-datatypes
        `((,names " = " "CreateDatatypes( " ,names " )" #\Newline)))
       ((mv translated properties kind)
        (create-sumtype-list sumtypes symbol-map types nil nil)))
    (mv `(,translated ,created-datatypes ,kind) properties)))
