;; Copyright (C) 2015, University of British Columbia
;; Written (originally) by Yan Peng (11th October, 2021)
;;
;; License: A 3-clause BSD license.
;; See the LICENSE file distributed with ACL2

(in-package "SMT")
(include-book "centaur/fty/top" :dir :system)
(include-book "xdoc/top" :dir :system)
(include-book "std/util/define" :dir :system)
(include-book "std/strings/top" :dir :system)

(include-book "../../verified/hint-interface")
(include-book "../../verified/basics")
(include-book "../property/datatype-property")
(include-book "translate-variable")
(include-book "translate-quote")

(local (in-theory (enable paragraph-p word-p string-or-symbol-p)))

(define translate-type ((type symbolp)
                        (type-info maybe-smt-type-p))
  :returns (translated stringp)
  (b* ((type (symbol-fix type))
       (type-info (maybe-smt-type-fix type-info))
       (basic? (assoc-equal type *SMT-types*))
       ((if basic?) (cdr basic?))
       ((unless type-info) (translate-variable type)))
    (translate-variable
     (smt-function->translation (smt-type->recognizer type-info))))
  ///
  (more-returns
   (translated (paragraph-p translated)
               :name paragraph-of-translate-type)))

(define create-destructor ((destructor smt-function-p)
                           (type smt-type-p))
  :returns (translated paragraph-p)
  (b* ((destructor (smt-function-fix destructor))
       ((smt-function f) destructor))
    `("('" ,(translate-variable f.translation) "', "
      ,(translate-type f.return-type type) ")")))

(define create-destructors ((destructors smt-function-list-p)
                            (type smt-type-p))
  :returns (translated paragraph-p)
  :measure (len destructors)
  (b* ((destructors (smt-function-list-fix destructors))
       (type (smt-type-fix type))
       ((unless (consp destructors)) nil)
       ((cons des-hd des-tl) destructors))
    `(", " ,(create-destructor des-hd type)
      ,@(create-destructors des-tl type))))

(define create-sum ((type smt-type-p)
                    (sum smt-sum-p))
  :returns (translated paragraph-p)
  (b* (((smt-type tp) (smt-type-fix type))
       ((smt-sum s) (smt-sum-fix sum))
       (name (translate-type (smt-function->name tp.recognizer) type))
       (constructor (translate-variable (smt-function->translation s.constructor)))
       (translated-destructors (create-destructors s.destructors type)))
    `(,name ".declare( '" ,constructor
            "'" ,translated-destructors " )" #\Newline)))

(define create-sum-list ((type smt-type-p)
                         (sum-lst smt-sum-list-p))
  :returns (translated paragraph-p)
  :measure (len sum-lst)
  (b* (((smt-type tp) (smt-type-fix type))
       (sum-lst (smt-sum-list-fix sum-lst))
       ((unless (consp sum-lst)) nil)
       ((cons sum-hd sum-tl) sum-lst))
    (cons (create-sum type sum-hd)
          (create-sum-list type sum-tl))))

(define create-sum-type ((type smt-type-p))
  :returns (translated paragraph-p)
  (b* ((type (smt-type-fix type))
       ((smt-type tp) type))
    (create-sum-list type tp.sums)))

(define translate-kind-sum ((recognizer smt-function-p)
                            (destructors smt-function-list-p))
  :returns (translation paragraph-p)
  :measure (len destructors)
  (b* ((recognizer (smt-function-fix recognizer))
       (destructors (smt-function-list-fix destructors))
       ((smt-function r) recognizer)
       ((unless (consp destructors)) nil)
       ((cons des-hd des-tl) destructors)
       ((smt-function d) des-hd))
    (cons `(,(translate-variable r.translation) "."
            ,(translate-variable d.translation) "(x), ")
          (translate-kind-sum recognizer des-tl))))

(define translate-kind-body ((rec smt-function-p)
                             (sum-lst smt-sum-list-p)
                             (symbol-map symbol-string-alistp))
  :returns (translation paragraph-p)
  :measure (len sum-lst)
  (b* ((rec (smt-function-fix rec))
       (sum-lst (smt-sum-list-fix sum-lst))
       (symbol-map (symbol-string-alist-fix symbol-map))
       ((unless (consp sum-lst)) `("Symbol_z3.z3Sym.kindNotFound"))
       ((cons sum-hd sum-tl) sum-lst)
       ((smt-sum s) sum-hd)
       ((smt-function c) s.constructor)
       ((smt-function r) rec)
       (tag-trans (cdr (assoc-equal s.tag symbol-map)))
       ((unless tag-trans)
        (er hard? 'translate-user-type=>translate-kind-body
            "Tag doesn't exist in symbol map: ~p0 ~p1~%" s.tag symbol-map))
       (trans-tl (translate-kind-body rec sum-tl symbol-map)))
    `("If(x == " ,(translate-variable r.translation) "."
      ,(translate-variable c.translation)
      "(" ,(translate-kind-sum r s.destructors) "), "
      ,tag-trans ", "
      ,trans-tl ")" )))

(define translate-kind ((kind smt-function-p)
                        (rec smt-function-p)
                        (sum-lst smt-sum-list-p)
                        (symbol-map symbol-string-alistp))
  :returns (translation paragraph-p)
  (b* ((kind (smt-function-fix kind))
       (rec (smt-function-fix rec))
       (sum-lst (smt-sum-list-fix sum-lst))
       (symbol-map (symbol-string-alist-fix symbol-map))
       ((smt-function k) kind)
       (first-line `("def " ,(translate-variable k.translation)
                     "(x): return "))
       (kind-body (translate-kind-body rec sum-lst symbol-map)))
    `(,first-line ,kind-body #\Newline)))

(define create-type ((type smt-type-p)
                     (symbol-map symbol-string-alistp)
                     (acc pseudo-term-list-listp))
  :returns (mv (translated paragraph-p)
               (properties pseudo-term-list-listp)
               (kind paragraph-p))
  (b* ((type (smt-type-fix type))
       (symbol-map (symbol-string-alist-fix symbol-map))
       (acc (pseudo-term-list-list-fix acc))
       ((smt-type tp) type)
       (name (translate-type (smt-function->name tp.recognizer) type))
       (datatype `(,name " = Datatype( '" ,name "' )" #\Newline))
       (declares (create-sum-type type))
       (new-acc (datatype-property type acc))
       ((unless tp.kind) (mv `(,datatype ,declares) new-acc nil))
       (curr-kind (translate-kind tp.kind tp.recognizer tp.sums symbol-map)))
    (mv `(,datatype ,declares) new-acc curr-kind)))

(local (in-theory (enable paragraph-p word-p)))

(define create-datatypes ((types symbol-smt-type-alist-p))
  :returns (created-names paragraph-p)
  :measure (len (symbol-smt-type-alist-fix types))
  (b* ((types (symbol-smt-type-alist-fix types))
       ((unless (consp types)) nil)
       ((cons t-hd t-tl) types)
       ((cons & tp) t-hd)
       (translated-name
        (translate-variable
         (smt-function->translation (smt-type->recognizer tp))))
       (names-tl (create-datatypes t-tl)))
    (cons `(,translated-name ", ") names-tl)))

(define create-type-list ((types symbol-smt-type-alist-p)
                          (symbol-map symbol-string-alistp)
                          (acc pseudo-term-list-listp)
                          (kind paragraph-p))
  :returns (mv (translated paragraph-p)
               (properties pseudo-term-list-listp)
               (new-kind paragraph-p))
  :measure (len (symbol-smt-type-alist-fix types))
  (b* ((types (symbol-smt-type-alist-fix types))
       (symbol-map (symbol-string-alist-fix symbol-map))
       (acc (pseudo-term-list-list-fix acc))
       (kind (paragraph-fix kind))
       ((unless (consp types)) (mv nil acc kind))
       ((cons t-hd t-tl) types)
       ((cons & tp) t-hd)
       ((mv trans acc-1 kind-hd) (create-type tp symbol-map acc))
       (kind-1 (cons kind-hd kind))
       ((mv trans-tl acc-2 kind-2)
        (create-type-list t-tl symbol-map acc-1 kind-1)))
    (mv (cons trans trans-tl) acc-2 kind-2)))

(define create-type-list-top ((types symbol-smt-type-alist-p)
                              (symbol-map symbol-string-alistp))
  :returns (mv (translated paragraph-p)
               (properties pseudo-term-list-listp))
  (b* ((types (symbol-smt-type-alist-fix types))
       (symbol-map (symbol-string-alist-fix symbol-map))
       ((if (null types)) (mv nil nil))
       (names (create-datatypes types))
       (create-datatypes
        `((,names " = " "CreateDatatypes( " ,names " )" #\Newline)))
       ((mv translated properties kind)
        (create-type-list types symbol-map nil nil)))
    (mv `(,translated ,create-datatypes ,kind) properties)))
