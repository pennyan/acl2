;; Copyright (C) 2015, University of British Columbia
;; Written (originally) by Yan Peng (19th October, 2021)
;;
;; License: A 3-clause BSD license.
;; See the LICENSE file distributed with ACL2

(in-package "SMT")
(include-book "centaur/fty/top" :dir :system)
(include-book "xdoc/top" :dir :system)
(include-book "std/util/define" :dir :system)
(include-book "std/strings/top" :dir :system)

(include-book "../../utils/basics")
(include-book "../../utils/fresh-vars")
(include-book "../../verified/hint-interface")

(define construct-type-predicate-list ((destructors smt-function-list-p)
                                       (formal-vars symbol-listp))
  :returns (type-predicates pseudo-termp)
  :measure (len destructors)
  (b* ((destructors (smt-function-list-fix destructors))
       (formal-vars (symbol-list-fix formal-vars))
       ((unless (and (consp destructors) (consp formal-vars))) ''t)
       ((cons des-hd des-tl) destructors)
       ((smt-function d) des-hd)
       ((cons formal-hd formal-tl) formal-vars))
    `(if (,d.return-type ,formal-hd)
         ,(construct-type-predicate-list des-tl formal-tl)
       'nil)))

(define construct-type-conclusion-list ((destructors smt-function-list-p)
                                        (return-var symbolp))
  :returns (type-concls pseudo-termp)
  :measure (len destructors)
  (b* ((destructors (smt-function-list-fix destructors))
       (return-var (symbol-fix return-var))
       ((unless (consp destructors)) ''t)
       ((cons des-hd des-tl) destructors)
       ((smt-function d) des-hd))
    `(if (,d.return-type (,d.name ,return-var))
         ,(construct-type-conclusion-list des-tl return-var)
       'nil)))

(define construct-type-of-constructor ((constructor smt-function-p)
                                       (destructors smt-function-list-p)
                                       (formal-vars symbol-listp)
                                       (acc pseudo-term-list-listp))
  :returns (new-acc pseudo-term-list-listp)
  (b* ((constructor (smt-function-fix constructor))
       (acc (pseudo-term-list-list-fix acc))
       (formal-vars (symbol-list-fix formal-vars))
       ((smt-function f) constructor)
       (type-predicates
        (construct-type-predicate-list destructors formal-vars))
       ((if (equal f.name 'quote))
        (er hard? 'construct-product=>construct-type-of-constructor
            "Function name should not be 'quote.~%"))
       (type-conclusion `(,f.return-type (,f.name ,@formal-vars))))
    (cons (list `(if ,type-predicates ,type-conclusion 't))
          acc)))

(define construct-type-of-destructors ((constructor smt-function-p)
                                       (destructors smt-function-list-p)
                                       (return-var symbolp)
                                       (acc pseudo-term-list-listp))
  :returns (new-acc pseudo-term-list-listp)
  (b* ((destructors (smt-function-list-fix destructors))
       (acc (pseudo-term-list-list-fix acc))
       (return-var (symbol-fix return-var))
       ((smt-function f) constructor)
       (type-predicate `(,f.return-type ,return-var))
       (type-conclusions (construct-type-conclusion-list destructors return-var)))
    (cons `(if ,type-predicate ,type-conclusions 't)
          acc)))

(define construct-destruct-equal-list ((constructor smt-function-p)
                                       (destructors smt-function-list-p)
                                       (formal-vars symbol-listp)
                                       (formal-vars-total symbol-listp))
  :returns (equal-list pseudo-termp)
  :measure (len destructors)
  (b* ((constructor (smt-function-fix constructor))
       (destructors (smt-function-list-fix destructors))
       (formal-vars (symbol-list-fix formal-vars))
       (formal-vars-total (symbol-list-fix formal-vars-total))
       ((unless (and (consp destructors) (consp formal-vars))) ''t)
       ((cons formal-hd formal-tl) formal-vars)
       ((cons des-hd des-tl) destructors)
       ((smt-function c) constructor)
       ((if (equal c.name 'quote))
        (er hard? 'construct-product=>construct-destruct-equal-list
            "Function name should not be 'quote.~%"))
       ((smt-function d) des-hd))
    `(if (equal (,d.name (,c.name ,@formal-vars-total)) ,formal-hd)
         ,(construct-destruct-equal-list constructor des-tl formal-tl formal-vars-total)
       'nil)))

(define destructor-of-constructors ((constructor smt-function-p)
                                    (destructors smt-function-list-p)
                                    (formal-vars symbol-listp)
                                    (acc pseudo-term-list-listp))
  :returns (new-acc pseudo-term-list-listp)
  (b* ((constructor (smt-function-fix constructor))
       (destructors (smt-function-list-fix destructors))
       (formal-vars (symbol-list-fix formal-vars))
       (acc (pseudo-term-list-list-fix acc))
       (type-predicates (construct-type-predicate-list destructors formal-vars))
       (equal-conclusions
        (construct-destruct-equal-list constructor destructors formal-vars
                                       formal-vars)))
    (cons (list `(if ,type-predicates ,equal-conclusions 't))
          acc)))

(define construct-destruct-list ((destructors smt-function-list-p)
                                 (return-var symbolp))
  :returns (destruct-lst pseudo-term-listp)
  :measure (len destructors)
  (b* ((destructors (smt-function-list-fix destructors))
       (return-var (symbol-fix return-var))
       ((unless (consp destructors)) nil)
       ((cons des-hd des-tl) destructors)
       ((smt-function d) des-hd)
       ((if (equal d.name 'quote))
        (er hard? 'construct-product=>construct-destruct-list
            "Function name should not be 'quote.~%")))
    (cons `(,d.name ,return-var)
          (construct-destruct-list des-tl return-var))))

(define constructor-of-destructors ((constructor smt-function-p)
                                    (destructors smt-function-list-p)
                                    (return-var symbolp)
                                    (acc pseudo-term-list-listp))
  :returns (new-acc pseudo-term-list-listp)
  (b* ((constructor (smt-function-fix constructor))
       (destructors (smt-function-list-fix destructors))
       (return-var (symbol-fix return-var))
       (acc (pseudo-term-list-list-fix acc))
       ((smt-function f) constructor)
       ((if (equal f.name 'quote))
        (er hard? 'construct-product=>constructor-of-destructors
            "Function name should not be 'quote.~%"))
       (type-predicate `(,f.return-type ,return-var))
       (destruct-lst (construct-destruct-list destructors return-var)))
    (cons (list `(implies ,type-predicate
                          (equal (,f.name ,@destruct-lst) ,return-var)))
          acc)))

(define construct-product ((type smt-type-p)
                           (acc pseudo-term-list-listp))
  :returns (acc pseudo-term-list-listp)
  (b* ((type (smt-type-fix type))
       (acc (pseudo-term-list-list-fix acc))
       ((smt-type tp) type)
       (vars (new-fresh-vars (1+ (len tp.destructors)) nil))
       ((cons return-var formal-vars) vars)
       (acc-1 (construct-type-of-constructor tp.constructor tp.destructors
                                             formal-vars acc))
       (acc-2 (construct-type-of-destructors tp.constructor tp.destructors
                                             return-var acc-1))
       (acc-3 (destructor-of-constructors tp.constructor tp.destructors
                                          formal-vars acc-2)))
    (constructor-of-destructors
     tp.constructor tp.destructors return-var acc-3)))
