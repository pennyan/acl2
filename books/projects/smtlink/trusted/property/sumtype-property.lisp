;; Copyright (C) 2015, University of British Columbia
;; Written (originally) by Yan Peng (19th October, 2021)
;;
;; License: A 3-clause BSD license.
;; See the LICENSE file distributed with ACL2

(in-package "SMT")
(include-book "centaur/fty/top" :dir :system)
(include-book "xdoc/top" :dir :system)
(include-book "std/util/define" :dir :system)
(include-book "std/strings/top" :dir :system)

(include-book "../../utils/basics")
(include-book "../../utils/fresh-vars")
(include-book "../../verified/hint-interface")
(include-book "uniqueness")
(include-book "get-equal")
(include-book "recognizer-property")
(include-book "equality-property")

(define construct-type-predicate-list ((destructors smt-function-list-p)
                                       (formal-vars symbol-listp))
  :returns (type-predicates pseudo-termp)
  :measure (len destructors)
  (b* ((destructors (smt-function-list-fix destructors))
       (formal-vars (symbol-list-fix formal-vars))
       ((unless (and (consp destructors) (consp formal-vars))) ''t)
       ((cons des-hd des-tl) destructors)
       ((smt-function d) des-hd)
       ((trans-hint th) d.translation-hint)
       ((cons formal-hd formal-tl) formal-vars))
    `(if (,th.return-type ,formal-hd)
         ,(construct-type-predicate-list des-tl formal-tl)
       'nil)))

(define construct-type-conclusion-list ((destructors smt-function-list-p)
                                        (return-var symbolp))
  :returns (type-concls pseudo-termp)
  :measure (len destructors)
  (b* ((destructors (smt-function-list-fix destructors))
       (return-var (symbol-fix return-var))
       ((unless (consp destructors)) ''t)
       ((cons des-hd des-tl) destructors)
       ((smt-function d) des-hd)
       ((trans-hint th) d.translation-hint))
    `(if (,th.return-type (,d.name ,return-var))
         ,(construct-type-conclusion-list des-tl return-var)
       'nil)))

(define type-of-constructor ((recognizer smt-function-p)
                             (constructor smt-function-p)
                             (destructors smt-function-list-p)
                             (prop-hints symbol-hints-alist-p)
                             (formal-vars symbol-listp)
                             (acc pseudo-term-list-listp))
  :returns (new-acc pseudo-term-list-listp)
  (b* ((recognizer (smt-function-fix recognizer))
       (constructor (smt-function-fix constructor))
       (prop-hints (symbol-hints-alist-fix prop-hints))
       (acc (pseudo-term-list-list-fix acc))
       (formal-vars (symbol-list-fix formal-vars))
       ((smt-function r) recognizer)
       ((smt-function f) constructor)
       ((trans-hint th) f.translation-hint)
       (type-predicates
        (construct-type-predicate-list destructors formal-vars))
       ((if (equal f.name 'quote))
        (er hard? 'sumtype-property=>construct-type-of-constructor
            "Function name should not be 'quote.~%"))
       (type-conclusion `(,th.return-type (,f.name ,@formal-vars)))
       (the-hint (get-hints r.name f.name :type-of-constructor prop-hints)))
    (cons (list `(hint-please ',the-hint)
                `(if ,type-predicates ,type-conclusion 't))
          acc)))

(define type-of-destructors ((recognizer smt-function-p)
                             (constructor smt-function-p)
                             (destructors smt-function-list-p)
                             (prop-hints symbol-hints-alist-p)
                             (return-var symbolp)
                             (acc pseudo-term-list-listp))
  :returns (new-acc pseudo-term-list-listp)
  (b* ((recognizer (smt-function-fix recognizer))
       (constructor (smt-function-fix constructor))
       (destructors (smt-function-list-fix destructors))
       (prop-hints (symbol-hints-alist-fix prop-hints))
       (acc (pseudo-term-list-list-fix acc))
       (return-var (symbol-fix return-var))
       ((unless (consp destructors)) acc)
       ((smt-function r) recognizer)
       ((smt-function f) constructor)
       ((trans-hint th) f.translation-hint)
       (type-predicate `(,th.return-type ,return-var))
       (type-conclusions
        (construct-type-conclusion-list destructors return-var))
       (the-hint (get-hints r.name f.name :type-of-destructors prop-hints)))
    (cons (list `(hint-please ',the-hint)
                `(if ,type-predicate ,type-conclusions 't))
          acc)))

(define construct-destruct-equal-list ((constructor smt-function-p)
                                       (destructors smt-function-list-p)
                                       (formal-vars symbol-listp)
                                       (formal-vars-total symbol-listp)
                                       (types symbol-smt-datatype-alist-p))
  :returns (equal-list pseudo-termp)
  :measure (len destructors)
  (b* ((constructor (smt-function-fix constructor))
       (destructors (smt-function-list-fix destructors))
       (formal-vars (symbol-list-fix formal-vars))
       (formal-vars-total (symbol-list-fix formal-vars-total))
       (types (symbol-smt-datatype-alist-fix types))
       ((unless (and (consp destructors) (consp formal-vars))) ''t)
       ((cons formal-hd formal-tl) formal-vars)
       ((cons des-hd des-tl) destructors)
       ((smt-function c) constructor)
       ((if (equal c.name 'quote))
        (er hard? 'sumtype-property=>construct-destruct-equal-list
            "Function name should not be 'quote.~%"))
       ((smt-function d) des-hd)
       (return-type (get-return-type d types))
       (equal (get-equal-from-type return-type)))
    `(if (,equal (,d.name (,c.name ,@formal-vars-total)) ,formal-hd)
         ,(construct-destruct-equal-list constructor des-tl formal-tl
                                         formal-vars-total types)
       'nil)))

(define destructor-of-constructors ((recognizer smt-function-p)
                                    (constructor smt-function-p)
                                    (destructors smt-function-list-p)
                                    (prop-hints symbol-hints-alist-p)
                                    (formal-vars symbol-listp)
                                    (types symbol-smt-datatype-alist-p)
                                    (acc pseudo-term-list-listp))
  :returns (new-acc pseudo-term-list-listp)
  (b* ((recognizer (smt-function-fix recognizer))
       (constructor (smt-function-fix constructor))
       (destructors (smt-function-list-fix destructors))
       (prop-hints (symbol-hints-alist-fix prop-hints))
       (formal-vars (symbol-list-fix formal-vars))
       (types (symbol-smt-datatype-alist-fix types))
       (acc (pseudo-term-list-list-fix acc))
       ((unless (consp destructors)) acc)
       (type-predicates
        (construct-type-predicate-list destructors formal-vars))
       (equal-conclusions
        (construct-destruct-equal-list constructor destructors formal-vars
                                       formal-vars types))
       ((smt-function r) recognizer)
       ((smt-function f) constructor)
       (the-hint
        (get-hints r.name f.name :destructor-of-constructor prop-hints)))
    (cons (list `(hint-please ',the-hint)
                `(if ,type-predicates ,equal-conclusions 't))
          acc)))

(define construct-destruct-list ((destructors smt-function-list-p)
                                 (return-var symbolp))
  :returns (mv (destruct-lst pseudo-term-listp)
               (fn-lst symbol-listp))
  :measure (len destructors)
  (b* ((destructors (smt-function-list-fix destructors))
       (return-var (symbol-fix return-var))
       ((unless (consp destructors)) (mv nil nil))
       ((cons des-hd des-tl) destructors)
       ((smt-function d) des-hd)
       ((mv destruct-tl fn-tl)
        (construct-destruct-list des-tl return-var)))
    (mv (cons `(,d.name ,return-var) destruct-tl)
        (cons d.name fn-tl))))

(define construct-construct-equal ((sum smt-sum-p)
                                   (return-var symbolp)
                                   (type smt-datatype-p))
  :returns (mv (equal-term pseudo-termp)
               (fn-lst symbol-listp))
  (b* ((sum (smt-sum-fix sum))
       (return-var (symbol-fix return-var))
       (type (smt-datatype-fix type))
       ((smt-sum s) sum)
       ((smt-function c) s.constructor)
       ((if (equal c.name 'quote))
        (mv (er hard? 'sumtype-property=>construct-construct-equal
                "Function name should not be 'quote.~%")
            nil))
       ((mv destruct-lst fn-lst)
        (construct-destruct-list s.destructors return-var))
       (equal (get-equal-from-type type)))
    (mv `(,equal (,c.name ,@destruct-lst) ,return-var)
        (cons c.name fn-lst))))

(define constructor-of-destructor-with-tag ((rec smt-function-p)
                                            (kind smt-function-p)
                                            (sum smt-sum-p)
                                            (prop-hints symbol-hints-alist-p)
                                            (return-var symbolp)
                                            (type smt-datatype-p)
                                            (types symbol-smt-datatype-alist-p)
                                            (acc pseudo-term-list-listp))
  :returns (new-acc pseudo-term-list-listp)
  (b* ((rec (smt-function-fix rec))
       (kind (smt-function-fix kind))
       (sum (smt-sum-fix sum))
       (prop-hints (symbol-hints-alist-fix prop-hints))
       (return-var (symbol-fix return-var))
       (type (smt-datatype-fix type))
       (types (symbol-smt-datatype-alist-fix types))
       (acc (pseudo-term-list-list-fix acc))
       ((smt-function r) rec)
       ((smt-function k) kind)
       ((smt-sum s) sum)
       ((smt-function f) s.constructor)
       (type-predicate `(,r.name ,return-var))
       (sym-equal (get-equal-from-type-alist 'symbolp types))
       (tag-predicate `(,sym-equal (,k.name ,return-var) ',s.tag))
       ((mv equality &) (construct-construct-equal s return-var type))
       (the-hint
        (get-hints r.name f.name :constructor-of-destructor-with-tag prop-hints)))
    (cons (list `(hint-please ',the-hint)
                `(if (if ,type-predicate ,tag-predicate 'nil)
                     ,equality
                   't))
          acc)))

(define tag-of-constructor ((recognizer smt-function-p)
                            (kind smt-function-p)
                            (sum smt-sum-p)
                            (prop-hints symbol-hints-alist-p)
                            (formal-vars symbol-listp)
                            (types symbol-smt-datatype-alist-p)
                            (acc pseudo-term-list-listp))
  :returns (new-acc pseudo-term-list-listp)
  (b* ((recognizer (smt-function-fix recognizer))
       (kind (smt-function-fix kind))
       (sum (smt-sum-fix sum))
       (prop-hints (symbol-hints-alist-fix prop-hints))
       (formal-vars (symbol-list-fix formal-vars))
       (types (symbol-smt-datatype-alist-fix types))
       (acc (pseudo-term-list-list-fix acc))
       ((smt-function r) recognizer)
       ((smt-function k) kind)
       ((smt-sum s) sum)
       ((smt-function c) s.constructor)
       (sym-equal (get-equal-from-type-alist 'symbolp types))
       ((if (or (equal k.name 'quote)
                (equal c.name 'quote)))
        (er hard? 'sumtype-property=>tag-of-constructor
            "Function name should not be 'quote.~%"))
       (type-predicate-lst
        (construct-type-predicate-list s.destructors formal-vars))
       (the-hint
        (get-hints r.name c.name :tag-of-constructor prop-hints)))
    (cons (list `(hint-please ',the-hint)
                `(if ,type-predicate-lst
                     (,sym-equal (,k.name (,c.name ,@formal-vars)) ',s.tag)
                   't))
          acc)))

(define construct-sum ((rec smt-function-p)
                       (kind maybe-smt-function-p)
                       (sum smt-sum-p)
                       (prop-hints symbol-hints-alist-p)
                       (return-var symbolp)
                       (type smt-datatype-p)
                       (types symbol-smt-datatype-alist-p)
                       (acc pseudo-term-list-listp))
  :returns (new-acc pseudo-term-list-listp)
  (b* ((rec (smt-function-fix rec))
       (kind (maybe-smt-function-fix kind))
       (sum (smt-sum-fix sum))
       (prop-hints (symbol-hints-alist-fix prop-hints))
       (return-var (symbol-fix return-var))
       (type (smt-datatype-fix type))
       (types (symbol-smt-datatype-alist-fix types))
       (acc (pseudo-term-list-list-fix acc))
       ((smt-sum s) sum)
       (formal-vars (new-fresh-vars (len s.destructors) `(,return-var)))
       (acc-1 (type-of-constructor
               rec s.constructor s.destructors prop-hints formal-vars acc))
       (acc-2 (type-of-destructors
               rec s.constructor s.destructors prop-hints return-var acc-1))
       (acc-3 (destructor-of-constructors
               rec s.constructor s.destructors prop-hints formal-vars
               types acc-2))
       ((unless kind) acc-3)
       (acc-4 (constructor-of-destructor-with-tag
               rec kind sum prop-hints return-var type types acc-3)))
    (tag-of-constructor rec kind sum prop-hints formal-vars types acc-4)))

(define construct-construct-equal-list ((sum-lst smt-sum-list-p)
                                        (return-var symbolp)
                                        (type smt-datatype-p))
  :returns (mv (equal-lst pseudo-termp)
               (fn-lst symbol-listp))
  :measure (len sum-lst)
  (b* ((sum-lst (smt-sum-list-fix sum-lst))
       (return-var (symbol-fix return-var))
       (type (smt-datatype-fix type))
       ((unless (consp sum-lst)) (mv ''nil nil))
       ((cons sum-hd sum-tl) sum-lst)
       ((mv equal-hd fn-hd)
        (construct-construct-equal sum-hd return-var type))
       ((mv equal-tl fn-tl)
        (construct-construct-equal-list sum-tl return-var type)))
    (mv `(cons ,equal-hd ,equal-tl)
        (append fn-hd fn-tl))))

(define constructor-of-destructors ((rec smt-function-p)
                                    (sum-lst smt-sum-list-p)
                                    (prop-hints symbol-hints-alist-p)
                                    (return-var symbolp)
                                    (type smt-datatype-p)
                                    (acc pseudo-term-list-listp))
  :returns (new-acc pseudo-term-list-listp)
  (b* ((rec (smt-function-fix rec))
       (sum-lst (smt-sum-list-fix sum-lst))
       (prop-hints (symbol-hints-alist-fix prop-hints))
       (return-var (symbol-fix return-var))
       (type (smt-datatype-fix type))
       (acc (pseudo-term-list-list-fix acc))
       ((smt-function r) rec)
       (type-predicate `(,r.name ,return-var))
       ((mv equal-lst &) (construct-construct-equal-list sum-lst return-var type))
       (the-hint (get-hints r.name nil :constructor-of-destructor prop-hints)))
    (cons (list `(hint-please ',the-hint)
                `(if ,type-predicate (exactly-one ,equal-lst) 't))
          acc)))

(define construct-kind-list ((kind smt-function-p)
                             (sum-lst smt-sum-list-p)
                             (return-var symbolp)
                             (types symbol-smt-datatype-alist-p))
  :returns (kind-lst pseudo-termp)
  :measure (len sum-lst)
  (b* ((kind (smt-function-fix kind))
       (sum-lst (smt-sum-list-fix sum-lst))
       (return-var (symbol-fix return-var))
       (types (symbol-smt-datatype-alist-fix types))
       ((unless (consp sum-lst)) ''nil)
       ((cons sum-hd sum-tl) sum-lst)
       ((smt-sum s) sum-hd)
       ((smt-function k) kind)
       (sym-equal (get-equal-from-type-alist 'symbolp types)))
    `(cons (,sym-equal (,k.name ,return-var) ',s.tag)
           ,(construct-kind-list kind sum-tl return-var types))))

(define tag-of-all ((rec smt-function-p)
                    (kind smt-function-p)
                    (sum-lst smt-sum-list-p)
                    (prop-hints symbol-hints-alist-p)
                    (return-var symbolp)
                    (types symbol-smt-datatype-alist-p)
                    (acc pseudo-term-list-listp))
  :returns (new-acc pseudo-term-list-listp)
  (b* ((rec (smt-function-fix rec))
       (kind (smt-function-fix kind))
       (sum-lst (smt-sum-list-fix sum-lst))
       (prop-hints (symbol-hints-alist-fix prop-hints))
       (return-var (symbol-fix return-var))
       (acc (pseudo-term-list-list-fix acc))
       (types (symbol-smt-datatype-alist-fix types))
       ((smt-function r) rec)
       ((if (equal r.name 'quote))
        (er hard? 'sumtype-property=>tag-of-all
            "Function name should not be 'quote.~%"))
       (type-predicate `(,r.name ,return-var))
       (kind-lst (construct-kind-list kind sum-lst return-var types))
       (the-hint (get-hints r.name nil :tag-uniqueness prop-hints)))
    (cons (list `(hint-please ',the-hint)
                `(if ,type-predicate
                     (exactly-one ,kind-lst)
                   't))
          acc)))

(define construct-sum-list ((rec smt-function-p)
                            (kind maybe-smt-function-p)
                            (sum-lst smt-sum-list-p)
                            (prop-hints symbol-hints-alist-p)
                            (return-var symbolp)
                            (type smt-datatype-p)
                            (types symbol-smt-datatype-alist-p)
                            (acc pseudo-term-list-listp))
  :returns (new-acc pseudo-term-list-listp)
  :measure (len sum-lst)
  (b* ((rec (smt-function-fix rec))
       (kind (maybe-smt-function-fix kind))
       (sum-lst (smt-sum-list-fix sum-lst))
       (prop-hints (symbol-hints-alist-fix prop-hints))
       (return-var (symbol-fix return-var))
       (type (smt-datatype-fix type))
       (types (symbol-smt-datatype-alist-fix types))
       (acc (pseudo-term-list-list-fix acc))
       ((unless (consp sum-lst)) acc)
       ((cons sum-hd sum-tl) sum-lst))
    (construct-sum-list
     rec kind sum-tl prop-hints return-var type types
     (construct-sum rec kind sum-hd prop-hints return-var type types acc))))

(define sumtype-property ((type smt-datatype-p)
                          (types symbol-smt-datatype-alist-p)
                          (acc pseudo-term-list-listp))
  :guard (equal (smt-datatype-kind type) :sumtype)
  :returns (new-acc pseudo-term-list-listp)
  (b* ((type (smt-datatype-fix type))
       (types (symbol-smt-datatype-alist-fix types))
       (acc (pseudo-term-list-list-fix acc))
       ((unless (mbt (equal (smt-datatype-kind type) :sumtype))) nil)
       (tp.recognizer (smt-datatype->recognizer type))
       (tp.prop-hints (smt-datatype->property-hints type))
       (tp.kind (smt-datatype-sumtype->kind type))
       (tp.sums (smt-datatype-sumtype->sums type))
       (return-var (car (new-fresh-vars 1 nil)))
       (acc-1 (recognizer-property type acc))
       (acc-2
        (construct-sum-list tp.recognizer tp.kind tp.sums tp.prop-hints
                            return-var type types acc-1))
       (acc-3
        (constructor-of-destructors tp.recognizer tp.sums tp.prop-hints
                                    return-var type acc-2))
       ((unless tp.kind) acc-3)
       (acc-4
        (tag-of-all tp.recognizer tp.kind tp.sums tp.prop-hints
                    return-var types acc-3)))
    (equality-property type acc-4)))
