;; Copyright (C) 2015, University of British Columbia
;; Written (originally) by Yan Peng (19th October, 2021)
;;
;; License: A 3-clause BSD license.
;; See the LICENSE file distributed with ACL2

(in-package "SMT")
(include-book "centaur/fty/top" :dir :system)
(include-book "xdoc/top" :dir :system)
(include-book "std/util/define" :dir :system)
(include-book "std/strings/top" :dir :system)

(include-book "../../utils/basics")
(include-book "../../utils/fresh-vars")
(include-book "../../verified/hint-interface")
(include-book "uniqueness")

(define construct-type-predicate-list ((destructors smt-function-list-p)
                                       (formal-vars symbol-listp))
  :returns (type-predicates pseudo-termp)
  :measure (len destructors)
  (b* ((destructors (smt-function-list-fix destructors))
       (formal-vars (symbol-list-fix formal-vars))
       ((unless (and (consp destructors) (consp formal-vars))) ''t)
       ((cons des-hd des-tl) destructors)
       ((smt-function d) des-hd)
       ((trans-hint th) d.translation-hint)
       ((cons formal-hd formal-tl) formal-vars))
    `(if (,th.return-type ,formal-hd)
         ,(construct-type-predicate-list des-tl formal-tl)
       'nil)))

(define construct-type-conclusion-list ((destructors smt-function-list-p)
                                        (return-var symbolp))
  :returns (type-concls pseudo-termp)
  :measure (len destructors)
  (b* ((destructors (smt-function-list-fix destructors))
       (return-var (symbol-fix return-var))
       ((unless (consp destructors)) ''t)
       ((cons des-hd des-tl) destructors)
       ((smt-function d) des-hd)
       ((trans-hint th) d.translation-hint))
    `(if (,th.return-type (,d.name ,return-var))
         ,(construct-type-conclusion-list des-tl return-var)
       'nil)))

(define type-of-constructor ((constructor smt-function-p)
                             (destructors smt-function-list-p)
                             (formal-vars symbol-listp)
                             (acc pseudo-term-list-listp))
  :returns (new-acc pseudo-term-list-listp)
  (b* ((constructor (smt-function-fix constructor))
       (acc (pseudo-term-list-list-fix acc))
       (formal-vars (symbol-list-fix formal-vars))
       ((smt-function f) constructor)
       ((trans-hint th) f.translation-hint)
       (type-predicates
        (construct-type-predicate-list destructors formal-vars))
       ((if (equal f.name 'quote))
        (er hard? 'datatype-property=>construct-type-of-constructor
            "Function name should not be 'quote.~%"))
       (type-conclusion `(,th.return-type (,f.name ,@formal-vars)))
       (the-hint `(:in-theory (enable))))
    (cons (list `(hint-please ',the-hint)
                `(if ,type-predicates ,type-conclusion 't))
          acc)))

(define type-of-destructors ((constructor smt-function-p)
                             (destructors smt-function-list-p)
                             (return-var symbolp)
                             (acc pseudo-term-list-listp))
  :returns (new-acc pseudo-term-list-listp)
  (b* ((destructors (smt-function-list-fix destructors))
       (acc (pseudo-term-list-list-fix acc))
       (return-var (symbol-fix return-var))
       ((unless (consp destructors)) acc)
       ((smt-function f) constructor)
       ((trans-hint th) f.translation-hint)
       (type-predicate `(,th.return-type ,return-var))
       (type-conclusions
        (construct-type-conclusion-list destructors return-var))
       (the-hint `(:in-theory (enable))))
    (cons (list `(hint-please ',the-hint)
                `(if ,type-predicate ,type-conclusions 't))
          acc)))

(define construct-destruct-equal-list ((constructor smt-function-p)
                                       (destructors smt-function-list-p)
                                       (formal-vars symbol-listp)
                                       (formal-vars-total symbol-listp))
  :returns (equal-list pseudo-termp)
  :measure (len destructors)
  (b* ((constructor (smt-function-fix constructor))
       (destructors (smt-function-list-fix destructors))
       (formal-vars (symbol-list-fix formal-vars))
       (formal-vars-total (symbol-list-fix formal-vars-total))
       ((unless (and (consp destructors) (consp formal-vars))) ''t)
       ((cons formal-hd formal-tl) formal-vars)
       ((cons des-hd des-tl) destructors)
       ((smt-function c) constructor)
       ((if (equal c.name 'quote))
        (er hard? 'datatype-property=>construct-destruct-equal-list
            "Function name should not be 'quote.~%"))
       ((smt-function d) des-hd))
    `(if (equal (,d.name (,c.name ,@formal-vars-total)) ,formal-hd)
         ,(construct-destruct-equal-list constructor des-tl formal-tl formal-vars-total)
       'nil)))

(define destructor-of-constructors ((constructor smt-function-p)
                                    (destructors smt-function-list-p)
                                    (formal-vars symbol-listp)
                                    (acc pseudo-term-list-listp))
  :returns (new-acc pseudo-term-list-listp)
  (b* ((constructor (smt-function-fix constructor))
       (destructors (smt-function-list-fix destructors))
       (formal-vars (symbol-list-fix formal-vars))
       (acc (pseudo-term-list-list-fix acc))
       ((unless (consp destructors)) acc)
       (type-predicates (construct-type-predicate-list destructors formal-vars))
       (equal-conclusions
        (construct-destruct-equal-list constructor destructors formal-vars
                                       formal-vars))
       (the-hint `(:in-theory (enable))))
    (cons (list `(hint-please ',the-hint)
                `(if ,type-predicates ,equal-conclusions 't))
          acc)))

(define construct-destruct-list ((destructors smt-function-list-p)
                                 (return-var symbolp))
  :returns (mv (destruct-lst pseudo-term-listp)
               (fn-lst symbol-listp))
  :measure (len destructors)
  (b* ((destructors (smt-function-list-fix destructors))
       (return-var (symbol-fix return-var))
       ((unless (consp destructors)) (mv nil nil))
       ((cons des-hd des-tl) destructors)
       ((smt-function d) des-hd)
       ((mv destruct-tl fn-tl)
        (construct-destruct-list des-tl return-var)))
    (mv (cons `(,d.name ,return-var) destruct-tl)
        (cons d.name fn-tl))))

(define construct-construct-equal ((sum smt-sum-p)
                                   (return-var symbolp))
  :returns (mv (equal-term pseudo-termp)
               (fn-lst symbol-listp))
  (b* ((sum (smt-sum-fix sum))
       (return-var (symbol-fix return-var))
       ((smt-sum s) sum)
       ((smt-function c) s.constructor)
       ((if (equal c.name 'quote))
        (mv (er hard? 'datatype-property=>construct-construct-equal
                "Function name should not be 'quote.~%")
            nil))
       ((mv destruct-lst fn-lst)
        (construct-destruct-list s.destructors return-var)))
    (mv `(equal (,c.name ,@destruct-lst) ,return-var)
        (cons c.name fn-lst))))

(define constructor-of-destructor-with-tag ((rec smt-function-p)
                                            (kind smt-function-p)
                                            (sum smt-sum-p)
                                            (return-var symbolp)
                                            (acc pseudo-term-list-listp))
  :returns (new-acc pseudo-term-list-listp)
  (b* ((rec (smt-function-fix rec))
       (kind (smt-function-fix kind))
       (sum (smt-sum-fix sum))
       (return-var (symbol-fix return-var))
       (acc (pseudo-term-list-list-fix acc))
       ((smt-function r) rec)
       ((smt-function k) kind)
       ((smt-sum s) sum)
       (type-predicate `(,r.name ,return-var))
       (tag-predicate `(equal (,k.name ,return-var) ',s.tag))
       ((mv equality &) (construct-construct-equal s return-var))
       ;; (the-hint `(:in-theory (enable ,r.name ,@fn-lst)))
       (the-hint `(:in-theory (enable))))
    (cons (list `(hint-please ',the-hint)
                `(if (if ,type-predicate ,tag-predicate 'nil)
                     ,equality
                   't))
          acc)))

(define tag-of-constructor ((kind smt-function-p)
                            (sum smt-sum-p)
                            (formal-vars symbol-listp)
                            (acc pseudo-term-list-listp))
  :returns (new-acc pseudo-term-list-listp)
  (b* ((kind (smt-function-fix kind))
       (sum (smt-sum-fix sum))
       (formal-vars (symbol-list-fix formal-vars))
       (acc (pseudo-term-list-list-fix acc))
       ((smt-function k) kind)
       ((smt-sum s) sum)
       ((smt-function c) s.constructor)
       ((if (or (equal k.name 'quote)
                (equal c.name 'quote)))
        (er hard? 'datatype-property=>tag-of-constructor
            "Function name should not be 'quote.~%"))
       (type-predicate-lst
        (construct-type-predicate-list s.destructors formal-vars))
       (the-hint `(:in-theory (enable))))
    (cons (list `(hint-please ',the-hint)
                `(if ,type-predicate-lst
                     (equal (,k.name (,c.name ,@formal-vars)) ',s.tag)
                   't))
          acc)))

(define construct-sum ((rec smt-function-p)
                       (kind maybe-smt-function-p)
                       (sum smt-sum-p)
                       (return-var symbolp)
                       (acc pseudo-term-list-listp))
  :returns (new-acc pseudo-term-list-listp)
  (b* ((rec (smt-function-fix rec))
       (kind (maybe-smt-function-fix kind))
       (sum (smt-sum-fix sum))
       (return-var (symbol-fix return-var))
       (acc (pseudo-term-list-list-fix acc))
       ((smt-sum s) sum)
       (formal-vars (new-fresh-vars (len s.destructors) `(,return-var)))
       (acc-1 (type-of-constructor s.constructor s.destructors formal-vars
                                   acc))
       (acc-2 (type-of-destructors s.constructor s.destructors return-var
                                   acc-1))
       (acc-3 (destructor-of-constructors s.constructor s.destructors
                                          formal-vars acc-2))
       ((unless kind) acc-3)
       (acc-4 (constructor-of-destructor-with-tag rec kind sum return-var
                                                  acc-3)))
    (tag-of-constructor kind sum formal-vars acc-4)))

(define construct-construct-equal-list ((sum-lst smt-sum-list-p)
                                        (return-var symbolp))
  :returns (mv (equal-lst pseudo-termp)
               (fn-lst symbol-listp))
  :measure (len sum-lst)
  (b* ((sum-lst (smt-sum-list-fix sum-lst))
       (return-var (symbol-fix return-var))
       ((unless (consp sum-lst)) (mv ''nil nil))
       ((cons sum-hd sum-tl) sum-lst)
       ((mv equal-hd fn-hd)
        (construct-construct-equal sum-hd return-var))
       ((mv equal-tl fn-tl)
        (construct-construct-equal-list sum-tl return-var)))
    (mv `(cons ,equal-hd ,equal-tl)
        (append fn-hd fn-tl))))

(define constructor-of-destructors ((rec smt-function-p)
                                    (sum-lst smt-sum-list-p)
                                    (return-var symbolp)
                                    (acc pseudo-term-list-listp))
  :returns (new-acc pseudo-term-list-listp)
  (b* ((rec (smt-function-fix rec))
       (sum-lst (smt-sum-list-fix sum-lst))
       (return-var (symbol-fix return-var))
       (acc (pseudo-term-list-list-fix acc))
       ((smt-function r) rec)
       (type-predicate `(,r.name ,return-var))
       ((mv equal-lst &) (construct-construct-equal-list sum-lst return-var))
       (the-hint `(:in-theory (enable))))
    (cons (list `(hint-please ',the-hint)
                `(if ,type-predicate (exactly-one ,equal-lst) 't))
          acc)))

(define construct-kind-list ((kind smt-function-p)
                             (sum-lst smt-sum-list-p)
                             (return-var symbolp))
  :returns (kind-lst pseudo-termp)
  :measure (len sum-lst)
  (b* ((kind (smt-function-fix kind))
       (sum-lst (smt-sum-list-fix sum-lst))
       (return-var (symbol-fix return-var))
       ((unless (consp sum-lst)) ''nil)
       ((cons sum-hd sum-tl) sum-lst)
       ((smt-sum s) sum-hd)
       ((smt-function k) kind))
    `(cons (equal (,k.name ,return-var) ',s.tag)
           ,(construct-kind-list kind sum-tl return-var))))

(define tag-of-all ((rec smt-function-p)
                    (kind smt-function-p)
                    (sum-lst smt-sum-list-p)
                    (return-var symbolp)
                    (acc pseudo-term-list-listp))
  :returns (new-acc pseudo-term-list-listp)
  (b* ((rec (smt-function-fix rec))
       (kind (smt-function-fix kind))
       (sum-lst (smt-sum-list-fix sum-lst))
       (return-var (symbol-fix return-var))
       (acc (pseudo-term-list-list-fix acc))
       ((smt-function r) rec)
       ((if (equal r.name 'quote))
        (er hard? 'datatype-property=>tag-of-all
            "Function name should not be 'quote.~%"))
       (type-predicate `(,r.name ,return-var))
       (kind-lst (construct-kind-list kind sum-lst return-var))
       (the-hint `(:in-theory (enable))))
    (cons (list `(hint-please ',the-hint)
                `(if ,type-predicate
                     (exactly-one ,kind-lst)
                   't))
          acc)))

(define construct-sum-list ((rec smt-function-p)
                            (kind maybe-smt-function-p)
                            (sum-lst smt-sum-list-p)
                            (return-var symbolp)
                            (acc pseudo-term-list-listp))
  :returns (new-acc pseudo-term-list-listp)
  :measure (len sum-lst)
  (b* ((rec (smt-function-fix rec))
       (kind (maybe-smt-function-fix kind))
       (sum-lst (smt-sum-list-fix sum-lst))
       (return-var (symbol-fix return-var))
       (acc (pseudo-term-list-list-fix acc))
       ((unless (consp sum-lst)) acc)
       ((cons sum-hd sum-tl) sum-lst))
    (construct-sum-list rec kind sum-tl return-var
                        (construct-sum rec kind sum-hd return-var acc))))

(define datatype-property ((type smt-type-p)
                           (acc pseudo-term-list-listp))
  :returns (new-acc pseudo-term-list-listp)
  (b* ((type (smt-type-fix type))
       (acc (pseudo-term-list-list-fix acc))
       ((smt-type tp) type)
       (return-var (car (new-fresh-vars 1 nil)))
       (acc-1
        (construct-sum-list tp.recognizer tp.kind tp.sums return-var acc))
       (acc-2
        (constructor-of-destructors tp.recognizer tp.sums return-var acc-1))
       ((unless tp.kind) acc-2))
    (tag-of-all tp.recognizer tp.kind tp.sums return-var acc-2)))
